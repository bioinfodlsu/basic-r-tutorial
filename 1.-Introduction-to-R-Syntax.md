
# 1. Introduction to R Syntax

**Daphne Janelyn L. Go** <br> *Bioinformatics Lab* <br> *Advanced
Research Institute for Informatics, Computing and Networking* <br> *De
La Salle University, Manila, Philippines*

R is an open source programming language that is popular for statistics
and data analysis. R was built by statisticians, so many common
statistical operations are built into the base language. R also features
powerful and intuitive libraries for plotting and a variety of packages
for predictive modeling, making it one of the most popular languages for
data science.

## Data Types

Decimal numbers (real numbers) in R are known as doubles. Doubles are
the default numeric data type so when you manually enter a number in R,
you are working with a double.

``` r
typeof(1)
```

    ## [1] "double"

``` r
typeof(-10.5)
```

    ## [1] "double"

``` r
typeof(Inf)
```

    ## [1] "double"

``` r
typeof(-Inf)
```

    ## [1] "double"

``` r
typeof(NaN) # dividing zero by zero produces NaN
```

    ## [1] "double"

Integers are a second numeric data type that only take whole numbered
values.

``` r
as.integer(1) # Convert the double 1 to integer 1
```

    ## [1] 1

``` r
typeof(as.integer(1))
```

    ## [1] "integer"

``` r
# Convert back from integer to double
as.numeric(as.integer(1))
```

    ## [1] 1

Our first non-numeric data type is the Logical. A Logical takes on the
value of TRUE or FALSE. You must type TRUE and FALSE in all capital
letters for R to recognize them as logical values. Data that only takes
on the values of True or False are also called “Booleans”.

``` r
typeof(TRUE)
```

    ## [1] "logical"

``` r
typeof(FALSE)
```

    ## [1] "logical"

``` r
typeof(T)
```

    ## [1] "logical"

``` r
typeof(F)
```

    ## [1] "logical"

You can create logical values with logical comparisons. R supports a
variety of standard logic comparison operators including \> (greater
than), \< (less than), \>= (greater than or equal), \<= (less than or
equal).

``` r
20 > 20
```

    ## [1] FALSE

``` r
20 >= 20
```

    ## [1] TRUE

``` r
10 == 10
```

    ## [1] TRUE

``` r
10 != 20
```

    ## [1] TRUE

``` r
!FALSE
```

    ## [1] TRUE

``` r
(2 > 1) & (10 == 9)
```

    ## [1] FALSE

``` r
(2 > 1) | (10 == 9)
```

    ## [1] TRUE

Strings of text in R are known as characters. Surround text with
quotation marks to create a character.

``` r
typeof("cat")
```

    ## [1] "character"

``` r
typeof("1")
```

    ## [1] "character"

``` r
typeof(as.numeric("12"))
```

    ## [1] "double"

``` r
typeof(as.character(12))
```

    ## [1] "character"

## Simple Arithmetic Operations¶

``` r
12 + 6 # addition
```

    ## [1] 18

``` r
12 - 6 # subtraction
```

    ## [1] 6

``` r
12 * 6 # multiplication
```

    ## [1] 72

``` r
12 / 6 # division
```

    ## [1] 2

``` r
12^6 # exponentiation
```

    ## [1] 2985984

``` r
12**6 # exponentiation
```

    ## [1] 2985984

``` r
12 %% 6 # modulo (get remainder)
```

    ## [1] 0

## Variables

A variable is a name you assign a value or object. After assigning a
variable, you can access its associated value or object using the
variable’s name. To simply put, this is how we store data. In R, assign
variables using \<- (the less than sign followed by a hyphen.).

``` r
var <- 3 + 3
x <- 10
y <- "R Workshop"
z <- (sqrt(144) == 12)

print(var)
```

    ## [1] 6

``` r
print(x)
```

    ## [1] 10

``` r
print(y)
```

    ## [1] "R Workshop"

``` r
print(z)
```

    ## [1] TRUE

It is possible to assign variables in R using the equals symbol =
instead of \<-. The equal sign is used for variable assignment in many
other programming languages (such as Python). One reason for using \<-
besides conforming to the style preferred by the R community is that the
equals sign is used in places other than variable assignment statements.
Functions often take named arguments and when calling a function you use
the = symbol to assign values to named arguments.

## Vectors or Collections

A vector is a sequence of data elements of the same data type. You can
have numeric, logical and character vectors.

To create and store a vector with specific values, use the c() function
and assign the result to a variable. c() takes a comma separated
sequence of elements as input and combines them into a vector. You can
also combine two vectors using the c() function. If you try to combine
vectors of different types, R will automatically convert the vectors
into the type that fits best.

``` r
# Creating a character vector for the days of the week
weekday <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")

weekend <- c("Saturday", "Sunday")

days <- c(weekday, weekend)

print(days)
```

    ## [1] "Monday"    "Tuesday"   "Wednesday" "Thursday"  "Friday"    "Saturday" 
    ## [7] "Sunday"

**Vector Indexing Starts at 1**

The first element is at index position 1, the second element is at index
position 2 and so on.

\*Note: unlike many other programming languages, indexes in R start at 1
instead of 0.

When you print a vector to the screen, each line starts with a number in
square brackets followed by vector values. The number in square brackets
indicates the index of the next value listed on that line.

You can access a specific value in a vector by typing the name of the
vector and then wrapping the index associated with the value you want to
access in square brackets.

``` r
days[1]
```

    ## [1] "Monday"

**Range of Values: Inclusive**

You can access ranges of values by placing a colon between the starting
and ending indices of the range:

``` r
days[1:3]
```

    ## [1] "Monday"    "Tuesday"   "Wednesday"

**Pulling out specific elements from Vectors**

``` r
days[c(1, 3, 5, 7)]
```

    ## [1] "Monday"    "Wednesday" "Friday"    "Sunday"

**Subset out of a Collection**

A subset of a vector is just a shorter vector. You can access a specific
subset of values by wrapping a vector in the square brackets.

``` r
weekdays <- days[1:5]
weekdays
```

    ## [1] "Monday"    "Tuesday"   "Wednesday" "Thursday"  "Friday"

**Generate a vector using 100 random Numbers**

``` r
random_data <- runif(100) # Create a vector of 100 random numbers

print(random_data)
```

    ##   [1] 0.82685014 0.79349133 0.88584978 0.58424367 0.26389537 0.62615329
    ##   [7] 0.50908531 0.69118950 0.07175820 0.95503106 0.41314884 0.33677529
    ##  [13] 0.28765553 0.85714624 0.09141045 0.46369820 0.07642723 0.98825042
    ##  [19] 0.15541167 0.27177348 0.45802341 0.72465666 0.15541445 0.94281332
    ##  [25] 0.17916994 0.81662091 0.16100344 0.28098054 0.80563069 0.89774605
    ##  [31] 0.46117937 0.05239727 0.89343660 0.30912735 0.99313517 0.01047602
    ##  [37] 0.15758016 0.94125745 0.22133441 0.16484320 0.64881411 0.58163789
    ##  [43] 0.23033298 0.29826535 0.51533661 0.65909042 0.41114673 0.28497723
    ##  [49] 0.08206858 0.69693789 0.64876895 0.33470689 0.51780499 0.48884075
    ##  [55] 0.27752557 0.74371842 0.81166464 0.70340838 0.09714771 0.59433541
    ##  [61] 0.48428067 0.41975363 0.05894641 0.23150154 0.96495239 0.53949528
    ##  [67] 0.47176298 0.87913832 0.60974253 0.97464295 0.93404019 0.68318169
    ##  [73] 0.25064318 0.35114473 0.43850785 0.27541890 0.79114709 0.13234097
    ##  [79] 0.27240220 0.04082356 0.01873174 0.48200228 0.55248415 0.76802129
    ##  [85] 0.15940459 0.05429243 0.06635341 0.01744347 0.51416888 0.83525773
    ##  [91] 0.90671483 0.05799638 0.99272268 0.10076493 0.20191224 0.24495700
    ##  [97] 0.63830223 0.38431948 0.60563381 0.18403722

``` r
print(length(random_data))
```

    ## [1] 100

**Filtering of Vectors using Logical Expressions** You can also index a
vector with a logical vector of the same length. In this case, the
subset is created from each index where the corresponding logical vector
is TRUE. Indexing with a logical vector is a common way to filter a
numeric or character vector for values that fulfill certain criteria.

``` r
# Exclude everything except for your specified index

y <- c(1, 0, 3)
y <- y[-2]
y
```

    ## [1] 1 3

``` r
# Exclude the range 2 to 9
random_data <- runif(50)
random_data_sub <- random_data[-(2:49)]
random_data_sub
```

    ## [1] 0.850137393 0.002642095

``` r
# Exclude using logical expression
over_half <- (random_data > 0.5)
new_subset <- random_data[over_half]
new_subset
```

    ##  [1] 0.8501374 0.8577529 0.5333704 0.7710713 0.9542953 0.6605092 0.5977180
    ##  [8] 0.8604190 0.7958614 0.8662339 0.8184905 0.9541340 0.7299567 0.7183901
    ## [15] 0.6116424 0.7610732 0.9712605 0.6277324 0.8955243 0.5113523 0.7852511
    ## [22] 0.8822130 0.6610573 0.8980901

**Use %in% to filter a vector**

``` r
my_letters <- c("a", "b", "c", "d", "a", "c")

# Get only the a's and c's
my_letters[my_letters %in% c("a", "c")]
```

    ## [1] "a" "c" "a" "c"

## Vectorized Operations

Many R functions and operations behave in a “vectorized” manner, meaning
they act upon each element of a vector individually and return the
result of each of the operations in a new vector. Vectorized operations
simplify the process of performing the same calculations on related
data. All the basic operators and functions we’ve learned so far that
operate on single values work on vectors longer than length 1.

``` r
example_vector <- c(1, 2, 3)

# adds to each value in the vector
example_vector + 10
```

    ## [1] 11 12 13

``` r
# performs subtraction on each value
example_vector - 10
```

    ## [1] -9 -8 -7

**Different Ways to Generate Vectors**

``` r
x <- 1:20
y <- seq(from = 1, to = 20, by = 2)
r <- rep(1, times = 10)
s <- runif(n = 5, min = 0, max = 100)

x
```

    ##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

``` r
y
```

    ##  [1]  1  3  5  7  9 11 13 15 17 19

``` r
r
```

    ##  [1] 1 1 1 1 1 1 1 1 1 1

``` r
s
```

    ## [1] 31.04375 56.16333 97.68340 37.65790 45.28336

## Control Flow

### If, Else and Else If

An if statement checks whether some logical expression is true or false
and executes a specified block of code if the logical expression is
true.

In R, an if statement starts with if, followed by a logical expression
in parentheses, followed by the code to execute when the if statement is
true in curly braces.

If statements are often accompanied by else statements. Else statements
come after if statements and allow you to execute code in the event that
the logical expression of an if statement is false.

``` r
x <- 5
if (x > 0) {
  print("Positive number")
} else {
  print("Negative number")
}
```

    ## [1] "Positive number"

### For Loops

For loops are a programming construct that let you go through each item
in a sequence and then perform some operation on each one.

``` r
my_sequence <- seq(0, 100, 10)

# Create a new loop over the specified items
for (item in my_sequence) {
  print(item)
}
```

    ## [1] 0
    ## [1] 10
    ## [1] 20
    ## [1] 30
    ## [1] 40
    ## [1] 50
    ## [1] 60
    ## [1] 70
    ## [1] 80
    ## [1] 90
    ## [1] 100

**The next keyword causes a for loop to skip to the next iteration of
the loop.**

``` r
my_sequence <- seq(0, 100, 10)
for (item in my_sequence) {
  if (item < 50) { # this if statement skips items less than 50
    next
  }
  print(item)
}
```

    ## [1] 50
    ## [1] 60
    ## [1] 70
    ## [1] 80
    ## [1] 90
    ## [1] 100

**The break keyword halts the execution of the loop entirely. Use break
to break out of a loop.**

``` r
my_sequence <- seq(0, 100, 10)

for (item in my_sequence) {
  if (item > 50) {
    break
  }
  print(item)
}
```

    ## [1] 0
    ## [1] 10
    ## [1] 20
    ## [1] 30
    ## [1] 40
    ## [1] 50

### While Loops

While loops are similar to for loops in that they allow you to execute
code over and over again. For loops execute their contents, at most, a
number of iterations equal to the length of the sequence you are looping
over. While loops, on the other hand, **keep executing their contents as
long as a certain logical expression you supply remains true.**

``` r
x <- 5
iterations <- 0

# Execute as long as iterations < x
while (iterations < x) {
  print("Study")
  iterations <- iterations + 1 # Increment iterations by 1 each time the loop executes
}
```

    ## [1] "Study"
    ## [1] "Study"
    ## [1] "Study"
    ## [1] "Study"
    ## [1] "Study"

### If Else on Vectors

For example, imagine you have a vector of numbers and you want to set
all the negative values in the vector to zero. One way to do it is to
use a for loop with an inner if statement.

``` r
my_vect <- runif(25, -1, 1) # Generate some random data between -1 and 1

for (index in 1:length(my_vect)) { # loop through the sequence 1:25
  number <- my_vect[index] # look up the next number using indexing
  if (number < 0) { # check if the number is less than 0
    my_vect[index] <- 0 # if so, set it to 0
  }
}

print(my_vect)
```

    ##  [1] 0.37469470 0.00000000 0.00000000 0.75472657 0.00000000 0.00000000
    ##  [7] 0.00000000 0.98116969 0.00000000 0.00000000 0.00000000 0.00000000
    ## [13] 0.00000000 0.00000000 0.03089412 0.00000000 0.17421105 0.00000000
    ## [19] 0.01527638 0.45578562 0.00000000 0.00000000 0.00000000 0.00000000
    ## [25] 0.04525215

Using a for loop requires writing quite a bit of code and loops are not
particularly fast.

Instead we could have used R’s ifelse() function to the same thing in a
vectorized manner. ifelse() takes a logical test as the first argument,
a value to return if the test is true as the second argument and a value
to return if the test is false as the third argument:

``` r
data <- c(11, 7, NA, 9, NA, 13, 15, NaN, 19, 17, 14, NaN)

# Use if else statements to conditionally fill these bad values with the mean

ifelse(is.na(data) | is.nan(data), # logical check
  mean(data, na.rm = T), # value to set if TRUE
  data
) # value to set if FALSE
```

    ##  [1] 11.000  7.000 13.125  9.000 13.125 13.000 15.000 13.125 19.000 17.000
    ## [11] 14.000 13.125

``` r
# Chaining ifelse to perform multiple operations
data <- c(11, 7, NA, 9, NA, 13, 15, NaN, 19, 17, 14, NaN)

d <- ifelse(is.na(data) | is.nan(data), "missing", ifelse(data < 10, "low", ifelse(data < 15, "medium", "high")))

table(d)
```

    ## d
    ##    high     low  medium missing 
    ##       3       2       3       4

## Functions

A function is just an R object that runs a per-defined snippet of code,
usually on some input that you supply to it. A function can return an
output based on the input you provide. For example, the sum() function
built into R simply takes a numeric vector as input and returns their
sum as output. Built-in functions and packages can take you a long way
in R, but it can be useful to define your own functions to perform
specific tasks outside the scope of built-in functions.

Create your own function in R using this syntax:

``` r
# Assign the function() to a name and declare arguments within ()
new_function <- function(arguments) {
  # Write a function body within the {} to execute
  for (x in 1:arguments) {
    print("This is a function!")
  }
}
```

Here is an actual example

``` r
exampleFunction <- function(x, y) {
  c(x + 1, y + 10)
}

exampleFunction(2, 4)
```

    ## [1]  3 14

**Functions with Return Value**

Functions in R return the last expression evaluated by default.

``` r
add_10 <- function(number) {
  number + 10
  # return (number+10)
}

add_10(5)
```

    ## [1] 15

``` r
add_20 <- function(number) {
  return(number + 20) # Exit and return specified value
  number + 10 # The function exits before running this line
}
```

## Function Arguments

A function can have one or more named arguments. You can assign a
default value to an argument when creating a function with the
argument_name = argument_value syntax.

``` r
sum_3_items <- function(x, y, z, print_args = TRUE) {
  if (print_args) {
    print(x)
    print(y)
    print(z)
  }
  return(x + y + z)
}
sum <- sum_3_items(1, 2, 3)
```

    ## [1] 1
    ## [1] 2
    ## [1] 3

``` r
sum2 <- sum_3_items(10, 20, 30, print_args = FALSE)
```

**Ellipsis**

The … argument collects all extra arguments passed to a function that
are not matched. The … argument can be used in functions where the
number of arguments is not known in advance.

``` r
addition_function <- function(...) {
  total <- 0
  # list (...) extracts the arguments to a list
  for (value in list(...)) {
    # Add each argument in ... to the total
    total <- total + value
  }
  total
}

addition_function(2, 4, 6, 8, 10, 12, 14)
```

    ## [1] 56
